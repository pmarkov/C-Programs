#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Декларираме структура Item, която съдържа полетата от условието
   typedef е за да не се налага да пишем "struct Item" всеки път като инициализираме структура от този тип, а само "Item"
*/
typedef struct Item {
	char name[31];
	int ID;
	char validationDate[11];
	double price;
} Item;

/* Правим нов тип структура, която съдържа една променлива от тип Item, в която се съхранява информацията за продукта
   и една променлива от тип указател към структура List, която съдържа адреса на следващия елемент от списъка
*/
typedef struct List {
	Item item;
	struct List *next;
} List;

// Създаваме указател, който винаги сочи в началото на списъка и ппц се именува head или root, както ти е по-удобно
List *head = NULL;

void createListFromFile() {

	/* Правим указател към файл fp и с него отваряме бинарния файл от условието,
	   като проверяваме дали се е отворил правилно. Ако не се е указателят ще има стойност NULL и тогава излизаме от програмата
	*/
	FILE *fp = fopen("input.bin", "rb");
	if (fp == NULL) {
		printf("Error opening file");
		exit(1);
	}
	
	Item new_item; // променлива от тип Item, в която ще запазваме информацията от файла
	while (1) {
		/* fread чете от файла байтове, с размера на типа Item и ги записва в new_item
		   ако не успее да прочете няма да върне едно следователно сме стигнали края на файла и излизаме от цикъла
		*/
		if (fread(&new_item, sizeof(Item), 1, fp) != 1) {
			break; 
		}
		/* Проверяваме дали това е първият елемент, който сме прочели и ако е заделяме памет за head с функцията malloc.
		   В head имаме 2 променливи, които можем да достъпим с оператора "->", защото head е указател.
		   Правим next да е равен на NULL, тъй като нямаме следващ елемент и не се знае къде може да сочи този указател
		   без да сме го инициализирали.
		*/
		if (head == NULL) {
			head = (List *)malloc(sizeof(List));
			head->item = new_item;
			head->next = NULL;
		}
		else {
			/* Правим нова променлива от тип указател към List, за която заделяме памет и записваме прочетената информация
			   от файла, след това даваме стойност на указателя next да сочи към първия елемент (този, към който сочи head),
			   за да не изгубим връзката към останалата част от списъка и правим head да сочи към новия елемент, който става първи
			*/
			List *temp = (List *)malloc(sizeof(List));
			temp->item = new_item;
			temp->next = head;
			head = temp;
		}
		/*
		else {
			* Това е за опашка, ако ти се падне. Правим нов указател, който е равен на head и с него отиваме до последния елемент
			* на списъка, след което създаваме нов елемент и го "закачаме" за последния (правим указателя next на последния да сочи
			* към новия) и next-а на новия елемент да сочи към NULL, тъй като е последен

			List *temp = head;
			while (temp->next != NULL) {
				temp = temp->next;
			}
			List* new_element = (List*)malloc(sizeof(List));
			new_element->item = new_item;
			new_element->next = NULL;
			temp->next = new_element;
		} */
	} 
	/* Функцията може да не връща стойност, тъй като head е глобална променлива и новата стойност, която ѝ задаваме 
	   в тази функция се запазва
	*/
}

void expiresIn(char date[11], List *head) {
	/* За да сравняваме числата от датата може да използваме ф-цията atoi(char *s), която приема
	   указател от тип char (един вид String) и го преобразува в число до първия срещнат символ, който не е число.
	   Демек ако напишем atoi(date) или atoi(&date[0]) подаваме указател към първия елемент от стринга и то ще преобразува числото,
	   което среща до "." и ще ни върне годината.
	*/

	int year = atoi(date);
	int month = atoi(&date[5]); // Използваме '&', защото date[5] е конкретен елемент и трябва да вземем стойността на адреса му
	int day = atoi(&date[8]);

	List *temp = head;
	while (temp != NULL) {
		// Правим същото с atoi за датата на съответния продукт
		int currYear = atoi(temp->item.validationDate);
		int currMonth = atoi(&temp->item.validationDate[5]);
		int currDay = atoi(&temp->item.validationDate[8]);
		
		int flag = 0; // Ползваме този флаг, за да знаем, след като са минали проверките, дали датата е по-голяма от зададената

		if (currYear > year) {
			flag = 1;
		}
		else if (currYear == year) {
			if (currMonth > month) {
				flag = 1;
			}
			else if (currMonth == month) {
				if (currDay > day) {
					flag = 1;
				}
			}
		}

		if (flag == 1) {
			printf("Name: %s", temp->item.name);
			printf("Price: %lf", temp->item.price);
		}
		temp = temp->next; /* Така отиваме на следващия елемент от структурата, като знаем, че последния елемент ще ни е NULL
							  и ще прекрати цикъла. Ако нямаме този ред ще получим безкраен цикъл.
						   */
	}
}

List *isIn(int ID, List *head) {
	
	List *temp = head;
	while (temp != NULL) {
		if (temp->item.ID == ID) {
			return temp;
		}
		temp = temp->next;
		/* Сравняваме ID-то на всеки елемент със зададеното, докато намерим съвпадение или докато свърши списъка
		   Ако намерим елемент със същото ID връщаме указателя, който сочи към него
		*/
	}
	return NULL; // Щом сме стигнали до тук не сме успели да намерим елемент с такова ID и връщаме NULL
	// Буквално това ти е цялата ф-ция :Д Даже няма нужда да правиш temp, защото по условие взимаш началото на списъка
	// като аргумент и няма да се промени ако го му променяме стойността, но в случая head ми е глобална и затова правя нов указател
}

void ADD(Item new_item, List element) {

	/* Заделяме памет за новия елемент и записваме в него информацията от new_item
	   Правим указателя към следващия елемент да бъде равен на указателя към следващия от елемента, който ни е подаден,
	   за да не губим връзката със следващите елементи от списъка.
	   След това пренасочваме указателя от element да сочи към елемента, който сме създали, за да изпълним условието на задачата
	*/
	List *new_element = (List*)malloc(sizeof(List)); 
	new_element->item = new_item;
	new_element->next = element.next;
	element.next = new_element;
}

// Не съм тествал функциите, но мисля, че ще свършат работа, а и нямаше предупреждения като го компилирах :Д
